# Code functions
And their usages
- **Value**: expression
- **Address**: expression with lvalue
- **execute**: statement definition program

---

## Address 
Variables:
```java
address[[Variable: expression -> ID]] = 

Variable var = (Variable)expression;
if (var.definition.scope == 0) {
	<pusha> exp.definition.offset
} else {
	<push> bp
	<pushi> exp.definition.offset
	<addi>
}
```

## Value CG
Integer constant:
```java
value[[IntLiteral: expression -> INT_CONSTANT]] =
<pushi> INT_CONSTANT
```
Character constant:
```java
value[[CharLiteral: expression -> CHAR_CONSTANT]] = 
<pushb> (int)CHAR_CONSTANT
```
Real constant:
```java
value[[DoubleLiteral: expression -> REAL_CONSTANT]] = 
<pushf> REAL_CONSTANT
```
Variables:
```java
value[[Variable: expression -> ID]] =
address[[expression]]
<load> var.definition.type.suffix
```
Arithmetic:
```java
value[[Arithmetic: expression1 -> expression2 ("+"|"-"|"*"|"/") expression3]] =
	
value[[expression2]]
expression2.type.convertTo(expression1.type)
value[[expression3]]
expression3.type.convertTo(expression1.type)

switch(expression1.operator) {
case "+": <add> expression1.type.suffix
	break;
case "-": <sub> epxression1.type.suffix	
	break;
case "*": <mul> expression1.type.suffix
	break;
case "/": <div> expression1.type.suffix
}
``` 
Unary Minus:
```java
value[[UnaryMinus: expression1 -> expression2]] = 

<push> expression1.type.suffix 0
value[[expression2]]

<sub> expression1.type.suffix
```
Comparison:
```java
value[[Comparison: expression1 -> expression2 ("<"|">"|"<="|">="|"=="|"!=") expression2]] =
	
value[[expression2]]
expression2.type.promotesTo(expression1.type)
value[[expression3]]
expression3.type.promotesTo(expression1.type)

switch (expression1.operator) {
case "<" : <lt> expression2.type.comparisonSuffix()
	break;
case ">" : <gt> expression2.type.comparisonSuffix()
	break;
case "<=": <lte> expression2.type.comparisonSuffix()
	break;
case ">=": <gte> expression2.type.comparisonSuffix()
	break;
case "==": <eq> expression2.type.comparisonSuffix()
	break;
case "!=": <ne> expression2.type.comparisonSuffix()
	break;
}
```
Logical:
```java
value[[Logical: expression1 -> expression2 ('&&'|'||') expression3]] =

value[[expression2]]
value[[expression3]]

switch(expression1.operator) {
case "&&": <and>
	break;
case '||': <or>
	break;
}
```
Unary not:
```java
value[[UnaryNot: expression1 -> expression2]]
value[[expression2]]
<not>
```

Casts:
```java
value[[Cast: expression1 -> type expression2]] = 
	
value[[expression2]]
expression2.type.converTo(type)
```

## Execute
Program:
```java
execute[[Program: program -> definition+]] = 

for (var def : definition*) {
	execute[[definition]]
}
```

Function definition:
```java
execute[[FunctionDefinition: definition -> type ID statement*]] = 
for (var stmt : statement*) {
	execute[[stmt]]
}
```
Read:
```java
execute[[Read: statement -> expression]]

```